const Reminder = require('../models/reminderModel');
const Appointment = require('../models/appointmentModel');
const User = require('../models/userModel');
const logger = require('../utils/logger');
const nodemailer = require('nodemailer');

// Email configuration
const transporter = nodemailer.createTransport({
  service: process.env.EMAIL_SERVICE || 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  }
});

// Create a reminder for an appointment
exports.createReminder = async (req, res) => {
  try {
    const { appointmentId, remindAt, method, message, autoReminder = false } = req.body;
    const userId = req.userId;
    
    if (!appointmentId || !remindAt || !message) {
      return res.status(400).json({ 
        success: false, 
        message: 'Missing required fields' 
      });
    }

    // Validate appointment exists
    const appointment = await Appointment.findById(appointmentId)
      .populate('userId', 'firstname lastname email mobile')
      .populate('doctorId', 'firstname lastname');

    if (!appointment) {
      return res.status(404).json({
        success: false,
        message: 'Appointment not found'
      });
    }

    // Check if user can create reminder for this appointment
    if (!autoReminder && appointment.userId._id.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'You can only create reminders for your own appointments'
      });
    }

    // Check if reminder already exists
    const existingReminder = await Reminder.findOne({
      appointmentId,
      method,
      sent: false
    });

    if (existingReminder) {
      return res.status(400).json({
        success: false,
        message: 'Reminder already exists for this appointment and method'
      });
    }

    const reminder = new Reminder({
      userId: appointment.userId._id,
      appointmentId,
      remindAt: new Date(remindAt),
      method: method || 'email',
      message,
      autoGenerated: autoReminder
    });

    await reminder.save();

    logger.info(`Reminder created for appointment ${appointmentId} to be sent at ${remindAt}`);

    res.status(201).json({ 
      success: true, 
      message: 'Reminder created successfully',
      reminder 
    });
  } catch (err) {
    logger.error('Error creating reminder:', err);
    res.status(500).json({ 
      success: false, 
      message: 'Unable to create reminder' 
    });
  }
};

// Create automatic reminders for an appointment
exports.createAutoReminders = async (appointmentId) => {
  try {
    const appointment = await Appointment.findById(appointmentId)
      .populate('userId', 'firstname lastname email mobile')
      .populate('doctorId', 'firstname lastname');

    if (!appointment) {
      logger.error(`Appointment ${appointmentId} not found for auto reminders`);
      return;
    }

    const appointmentDateTime = new Date(appointment.date);
    const [hours, minutes] = appointment.time.split(':');
    appointmentDateTime.setHours(parseInt(hours), parseInt(minutes));

    // Create reminders: 24 hours, 2 hours, and 30 minutes before
    const reminderTimes = [
      { hours: 24, method: 'email' },
      { hours: 2, method: 'email' },
      { hours: 0.5, method: 'sms' } // 30 minutes
    ];

    const reminders = [];
    
    for (const { hours, method } of reminderTimes) {
      const remindAt = new Date(appointmentDateTime);
      remindAt.setHours(remindAt.getHours() - hours);

      // Don't create reminders for past times
      if (remindAt > new Date()) {
        const message = generateReminderMessage(appointment, hours);
        
        const reminder = new Reminder({
          userId: appointment.userId._id,
          appointmentId,
          remindAt,
          method,
          message,
          autoGenerated: true
        });

        reminders.push(reminder);
      }
    }

    if (reminders.length > 0) {
      await Reminder.insertMany(reminders);
      logger.info(`Created ${reminders.length} auto reminders for appointment ${appointmentId}`);
    }

  } catch (error) {
    logger.error('Error creating auto reminders:', error);
  }
};

// Get reminders for user
exports.getReminders = async (req, res) => {
  try {
    const userId = req.userId;
    const { status = 'all', method, page = 1, limit = 20 } = req.query;

    const filter = { userId };
    if (status !== 'all') {
      filter.sent = status === 'sent';
    }
    if (method) {
      filter.method = method;
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const reminders = await Reminder.find(filter)
      .populate({
        path: 'appointmentId',
        populate: {
          path: 'doctorId',
          select: 'firstname lastname specialization'
        }
      })
      .sort({ remindAt: 1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Reminder.countDocuments(filter);

    res.json({ 
      success: true, 
      data: {
        reminders,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(total / parseInt(limit)),
          totalItems: total,
          itemsPerPage: parseInt(limit)
        }
      }
    });
  } catch (err) {
    logger.error('Error fetching reminders:', err);
    res.status(500).json({ 
      success: false, 
      message: 'Unable to fetch reminders' 
    });
  }
};

// Send due reminders
exports.sendDueReminders = async (req, res) => {
  try {
    const now = new Date();
    const dueReminders = await Reminder.find({
      remindAt: { $lte: now },
      sent: false
    })
    .populate({
      path: 'appointmentId',
      populate: [
        { path: 'userId', select: 'firstname lastname email mobile' },
        { path: 'doctorId', select: 'firstname lastname specialization' }
      ]
    });

    let sentCount = 0;
    let failedCount = 0;

    for (const reminder of dueReminders) {
      try {
        const success = await sendReminder(reminder);
        if (success) {
          reminder.sent = true;
          reminder.sentAt = new Date();
          await reminder.save();
          sentCount++;
        } else {
          failedCount++;
        }
      } catch (error) {
        logger.error(`Failed to send reminder ${reminder._id}:`, error);
        failedCount++;
      }
    }

    logger.info(`Sent ${sentCount} reminders, ${failedCount} failed`);

    res.json({
      success: true,
      message: `Processed ${dueReminders.length} due reminders`,
      data: {
        total: dueReminders.length,
        sent: sentCount,
        failed: failedCount
      }
    });

  } catch (err) {
    logger.error('Error sending due reminders:', err);
    res.status(500).json({
      success: false,
      message: 'Error processing reminders'
    });
  }
};

// Mark reminder as sent
exports.markSent = async (req, res) => {
  try {
    const { reminderId } = req.params;
    const reminder = await Reminder.findById(reminderId);
    
    if (!reminder) {
      return res.status(404).json({ 
        success: false, 
        message: 'Reminder not found' 
      });
    }

    reminder.sent = true;
    reminder.sentAt = new Date();
    await reminder.save();

    res.json({ 
      success: true,
      message: 'Reminder marked as sent'
    });
  } catch (err) {
    logger.error('Error marking reminder as sent:', err);
    res.status(500).json({ 
      success: false, 
      message: 'Unable to mark as sent' 
    });
  }
};

// Delete reminder
exports.deleteReminder = async (req, res) => {
  try {
    const { reminderId } = req.params;
    const userId = req.userId;

    const reminder = await Reminder.findById(reminderId);
    if (!reminder) {
      return res.status(404).json({
        success: false,
        message: 'Reminder not found'
      });
    }

    // Check if user owns this reminder
    if (reminder.userId.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'You can only delete your own reminders'
      });
    }

    await Reminder.findByIdAndDelete(reminderId);

    res.json({
      success: true,
      message: 'Reminder deleted successfully'
    });

  } catch (err) {
    logger.error('Error deleting reminder:', err);
    res.status(500).json({
      success: false,
      message: 'Unable to delete reminder'
    });
  }
};

// Helper function to send reminder
async function sendReminder(reminder) {
  const { method, message, appointmentId } = reminder;
  const { userId: patient, doctorId: doctor } = appointmentId;

  try {
    if (method === 'email' && patient.email) {
      await transporter.sendMail({
        from: process.env.EMAIL_USER,
        to: patient.email,
        subject: 'Appointment Reminder',
        html: `
          <h2>Appointment Reminder</h2>
          <p>Dear ${patient.firstname} ${patient.lastname},</p>
          <p>${message}</p>
          <div style="margin: 20px 0; padding: 15px; background-color: #f5f5f5; border-radius: 5px;">
            <strong>Appointment Details:</strong><br>
            Doctor: Dr. ${doctor.firstname} ${doctor.lastname}<br>
            Date: ${new Date(appointmentId.date).toLocaleDateString()}<br>
            Time: ${appointmentId.time}<br>
            ${doctor.specialization ? `Specialization: ${doctor.specialization}` : ''}
          </div>
          <p>Please arrive 15 minutes early for your appointment.</p>
          <p>Best regards,<br>Healthcare Team</p>
        `
      });
      return true;
    } else if (method === 'sms' && patient.mobile) {
      // SMS implementation would go here
      // For now, we'll log it
      logger.info(`SMS reminder sent to ${patient.mobile}: ${message}`);
      return true;
    }
    
    return false;
  } catch (error) {
    logger.error('Error sending reminder:', error);
    return false;
  }
}

// Helper function to generate reminder message
function generateReminderMessage(appointment, hoursBefore) {
  const { userId: patient, doctorId: doctor } = appointment;
  const timeText = hoursBefore >= 1 ? 
    `${hoursBefore} hour${hoursBefore > 1 ? 's' : ''}` : 
    '30 minutes';

  return `Hi ${patient.firstname}, this is a reminder that you have an appointment with Dr. ${doctor.firstname} ${doctor.lastname} in ${timeText} on ${new Date(appointment.date).toLocaleDateString()} at ${appointment.time}.`;
}

// Delete reminder
exports.deleteReminder = async (req, res) => {
  try {
    const { reminderId } = req.params;
    await Reminder.findByIdAndDelete(reminderId);
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Unable to delete reminder' });
  }
};
